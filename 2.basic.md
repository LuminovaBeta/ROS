# 创建一个ros节点
用cpp的主while循环如果用true作为参数，则不会响应外部输入，如`^C`，可用`ros::ok()`作为参数

index.ros.org可以查看std_msgs的消息类型标准定义格式

图形化显示节点之间的关系
```
rqt_graph
```
# cpp
## 代码核心
```cpp
ros::init(argc, argv, "name_node")
ros::Nodehandle nh
```
- `ros::Nodehandle nh`：初始化类，使节点能够与ros master进行通信，并且能够用nh创建发布者和订阅者

## 发布者
```cpp
ros::Publisher pub = nh.advertise<std_msgs::String>("machao", 10);
```
- `nh.advertise("话题名称", 缓存长度)`:泛型函数
- `ros::Rate loop_rate(rate_Hz_num);`：设置发布频率，通过`loop_rate.sleep();`在主循环中执行

## 订阅者
```cpp
ros::Subscriber sub = nh.subscribe<std_msgs::String>("machao", 10, chao);
ROS_INFO(msg.data.c_str());
# ROS_WARN(msg.data.c_str());
ros::spinOnce();
```
- `nh.subscribe("话题名称", 缓存长度, 回调函数)`
- `ROS_INFO`：带时间戳的日志输出，DEBUG	INFO WARN ERROR
- `ros::spinOnce()`: 处理待执行的回调函数，因此要放到主循环里

# launch
```
<node pkg="pkg_name" type="node" name="node_name">
```
- `pkg="pkg_name"`：包名
- `type="node"` `name="node_name">`：节点与节点名字
- `output="screen"`：可选参数添加（默认INFO类型的日志输出是不显示的）
- `launch-prefix="gnome-terminal -e"`：属性，可以让节点单独运行在一个独立终端中
- launch文件只要包含节点名字，都会自动启动roscore

# py
```python
rospy.init_node("node_name")
pub = rospy.Publisher("topic_name", String, queue_size=10)
sub = rospy.Subscriber("topic_name", String, chao_callback, queue_size=10)
```
因为cpp的节点是生成的二进制可执行文件，而python的节点是.py文件，launch不要忘记`.py`的后缀
